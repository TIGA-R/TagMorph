

class Audit:
	def __init__(
		self, 
		tagProvider, 
		tableName, 
		suffix='',
		querySize=1000, 
		dbName='tagdb', 
	):
		""" 
		Class to audit tags generated by the tagmorph module
		
		Args:
		--------
		tagProvider (str): name of the tag provider from Ignition Gateway configuration to audit
		suffix (str): name appended to tag to grab subdata (e.g. '.OpcItemPath'). Make sure to include proper delimiter (typically '.')
		querySize (int): Size of query to pull at a time; iterated over to complete full audit
		dbName (str): Name of db from Ignition Gateway configuration
		tableName (str): Name of audit table
		
		Generated Properties:
		--------
		rowCount (int): last id of the audit table 
		"""
		self.tagProvider = tagProvider
		self.suffix = suffix
		self.querySize = querySize
		self.tableName = tableName
		self.dbName = dbName
		countQuery = """
		select max(id) from %s limit 1
		"""%self.tableName
		self.rowCount = int(system.db.runQuery(countQuery, 'tagdb')[0][0])
		
	def tagQuery(self, index):
		""" 
		Query a set of data from the audit db prepended with the tag provider and appended with the suffix data
		
		Args:
		--------
		index (int): starting id to query records from audit db
		
		Returns:
			PyDataset: set of tagnames with prefix and suffix to generate tag-queriable tagpaths
		"""
		start = index
		end = index + self.querySize
		prefix = self.prefixCaseSwitch(self.tagProvider)
		caseStatement = ' '.join((line + " || tagpath || '%s'"%self.suffix for line in prefix))
		query = """
		select case substr(tagpath, 1, instr(tagpath, '/'))
			%s
			else tagpath
			end qualtagpath
		from %s
		where id between %d and %d
		"""%(caseStatement, self.tableName, start, end)
		return system.db.runQuery(query, self.dbName)
	
	def tagRead(self, index):
		""" 
		Build a set of qualified tag values based on the tag list generated by self.tagQuery
		
		Args:
		--------
		index (int): starting id to query records from audit db
		
		Returns:
			A list of qualified values based on the queried tag records
		"""
		tagPaths = self.tagQuery(index).getColumnAsList(0)
#		print tagPaths
		return system.tag.readBlocking(tagPaths)
		system.tag.read
	
	def tagVals(self, index):
		""" 
		Build a set of qualified tag values based on the tag list generated by self.tagQuery

		Args:
		--------
		index (int): starting id to query records from audit db
		
		Returns:
			A list of tag values based on the queried tag records
		"""
		return (tag.value for tag in self.tagRead(index))
	
	def updateAuditCaseSwitch(self, index):
		"""
		Build a generator to produce update case switch statements as part of the sqlite audit update string
		
		Args:
		--------
		
		Yields:
			iter: Sequence of when (id) then (value) statements 
		"""
		tagBase = "when %d then '%s'"
		return (tagBase%(index + idx, val) for idx, val in enumerate(self.tagVals(index)) if val is not None)
	
	def updateQuery(self, index, column):
		"""
		Build out the update query for the sqlite audit posting.
		
		Args:
		--------
		index (int): Starting id to query records from audit db
		column (str): Name of the database column to post updates to (e.g. 'original' | 'modified')
		
		Returns:
			str: Update query for the audit DB
		"""
		caseSwitch = ' '.join(self.updateAuditCaseSwitch(index))
		start = index
		end = index + self.querySize
		updateBase = """
		update %s
		set %s = CASE id
		%s
		else ''
		end
		where id between %d and %d;
		"""%(self.tableName, column, caseSwitch, start, end)
		return updateBase
	
	def audit(self, column):
		"""
		Perform the audit, updating `column` in the audit database
		
		Args:
		---------
		column (str): Name of the database column to post updates to (e.g. 'original' | 'modified')
		
		Returns:
			None
		"""
		for index in self.indexGenerator(self.querySize, self.rowCount):
			system.db.runUpdateQuery(self.updateQuery(index, column), database=self.dbName)
		
	
	@staticmethod
	def prefixCaseSwitch(tagProvider):
		""" 
		Builds a set of `WHEN x THEN y` cases for prepending tag info to tagpaths in the sqlite database.
		
		Args:
		--------
		tagProvider (str): tag provider name the tags are configured on
		
		Yields:
			str: yields `WHEN x THEN y` statements for each key, value pair of the enclosed case_dict 
		"""
		case_dict = {
		'_types_/': '[%s]',
		'South01/': '[%s]South/',
		'North01/': '[%s]North/',
		}
		return ("WHEN '%s' THEN '%s'"%(key, val%tagProvider) for key, val in case_dict.items())
	
	@staticmethod
	def indexGenerator(indexSize, maxNum):
		"""
		Yields each index from 0 to `maxNum` in increments of `indexSize`
		
		Args:
		-------
		indexSize (int): Size of index to process each yield
		maxNum (int): Size of audit
		
		Yields:
			int: The next index until maxNum is reached.
		"""
		num = 0
		while num < maxNum:
			yield num
			num += indexSize
			if num > maxNum:
				num = maxNum
				

